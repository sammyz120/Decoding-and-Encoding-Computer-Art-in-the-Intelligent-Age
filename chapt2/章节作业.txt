//参考：小红书：对对品如
Particle2[] par;// 定义Particle2数组

void setup() {
  size(320,320);// 设置画布
  par = new Particle2[50]; // 创建50个对象
  for (int i = 0; i < 50; i++) {
    par[i] = new Particle2();
  }
}

void draw() {
  
  noStroke();// 不绘制边框
  background(0);// 背景
  
  
  fill(255,255,255);
rect(0,0,70,30);
//第一个
fill(255,255,255);
rect(80,0,130,30);
//第二个
fill(200,153,3);
rect(220,0,70,30);
//第三个
fill(255,255,255);
rect(300,0,20,240);
//第四个
fill(255,255,255);
rect(0,40,40,200);
//第五个
fill(170,0,1);
rect(50,40,160,160);
//第六个
fill(200,153,3);
rect(220,40,70,90);
//第七个
fill(255,255,255);
rect(220,140,30,60);
//第八个
fill(255,255,255);
rect(260,140,30,60);
//第九个
fill(255,255,255);
rect(130,210,80,30);
//第十个
fill(255,255,255);
rect(220,210,70,30);
//第11个
fill(200,153,3);
rect(0,250,40,70);
//第12个
fill(255,255,255);
rect(50,250,70,20);
//第13个
fill(255,255,255);
rect(50,280,70,40);
//第14个
fill(255,255,255);
rect(130,250,80,30);
//第15个
fill(39,35,156);
rect(230,250,70,50);
//第16个
fill(170,0,1);
rect(310,250,20,70);
//第17个
fill(255,255,255);
rect(130,310,160,10);
//第18个 


  for (int i = 0; i < 50; i++) {
    par[i].drawParticle(); // 绘制每个粒子
  }
}

class Particle2 {// 定义Particle2类
  float xPosition; 
  float yPosition;
  float size;// 粒子的坐标和大小

  float speedX;// 粒子的运动速度和颜色
  float speedY;
  float col;

  Particle2() {// 随机位置和速度
    xPosition = random(0, width);
    yPosition = random(0, height);

    speedX = random(-3, 3);
    speedY = random(-3, 3);

    size = random(10, 20);// 随机大小和颜色
    col = random(100, 255);
  }

  void drawParticle() {
    fill(col, col - 15, 255); // 设置随机颜色
    ellipse(xPosition, yPosition, size, size); // 绘制圆形粒子

    xPosition += speedX;// 重做粒子的位置
    yPosition += speedY;

    if (yPosition > height) { // 粒子y轴方向上碰到边界反弹
      yPosition = height;
      speedY = -1 * speedY;
    }

    if (yPosition < 0) {
      yPosition = 0;
      speedY = -1 * speedY;
    }

    if (xPosition > width) {// 粒子x轴方向上碰到边界反弹
      xPosition = width;
      speedX = -1 * speedX;
    }

    if (xPosition < 0) {
      xPosition = 0;
      speedX = -1 * speedX;
    }

    if (mousePressed) {// 鼠标按下
      float xdist = xPosition - mouseX;
      float ydist = yPosition - mouseY;

      xPosition -= xdist * 0.1;//在x轴上回到鼠标
      yPosition -= ydist * 0.1;//在y轴上回到鼠标
    }
  }
}
